stages:
  - prepare
  - build
  - deploy

test-before-build:
  stage: prepare
  image: alpine:3.20
  before_script:
    - apk add --no-cache openssh-client
    - mkdir -p ~/.ssh
    - cp "$SSH_PRIVATE_KEY" ~/.ssh/id_ed25519
    - chmod 600 ~/.ssh/id_ed25519
    - ssh-keyscan -H "$VPS_HOST" >> ~/.ssh/known_hosts
  script:
    - |
      ssh "$VPS_USER@$VPS_HOST" << 'EOF'
        set -ex
        echo "== whoami =="
        whoami
      EOF
  only:
    - main    
  environment:
    name: production

build_backend_image:
  stage: build
  image: docker:24.0.7
  services:
    - docker:24.0.7-dind
  variables:
    DOCKER_TLS_CERTDIR: ""
  when: manual
  before_script:
    - apk add --no-cache openjdk21-jdk maven git
    - java -version
    - mvn -v
  script:
    - |
      set -euo pipefail

      echo "== Build Maven project =="
      cd BackEnd
      mvn clean package -DskipTests
      cd ..

      IMAGE_NAME="$CI_REGISTRY_IMAGE"
      TAG_SHA="$CI_COMMIT_SHA"

      echo "IMAGE_NAME=$IMAGE_NAME"
      echo "TAG_SHA=$TAG_SHA"

      echo "== Login to GitLab Container Registry =="
      echo "$CI_REGISTRY_PASSWORD" | docker login "$CI_REGISTRY" -u "$CI_REGISTRY_USER" --password-stdin

      echo "== Build docker image =="
      docker build \
        -f BackEnd/DockerFile \
        -t "$IMAGE_NAME:$TAG_SHA" \
        BackEnd

      echo "== Push image =="
      docker push "$IMAGE_NAME:$TAG_SHA"

      echo "== Build done. Tag for deploy =="
      echo "  $IMAGE_NAME:$TAG_SHA"

deploy_to_k8s:
  stage: deploy
  image: alpine:3.20
  when: manual       
  only:
    - main            
  variables:
    NS: "default"   
  before_script:
    - apk add --no-cache curl gettext bash

    # 1) Check KUBECONFIG_INLINE
    - |
      if [ -z "$KUBECONFIG_INLINE" ]; then
        echo "ERROR: KUBECONFIG_INLINE not set"; exit 1;
      fi

    # 2) Write ~/.kube/config
    - |
      set -euo pipefail
      mkdir -p ~/.kube

      KUBECTL_VERSION="v1.30.2"
      curl -LO "https://dl.k8s.io/release/${KUBECTL_VERSION}/bin/linux/amd64/kubectl"
      install -m 0755 kubectl /usr/local/bin/kubectl
      kubectl version --client

      # Write kubeconfig
      printf '%s' "$KUBECONFIG_INLINE" | base64 -d > ~/.kube/config

      if [ ! -s ~/.kube/config ]; then
        echo "❌ ~/.kube/config not created"; exit 1;
      fi

      chmod 600 ~/.kube/config

    # 3) debug kubeconfig
    - |
      echo "== Checking server address =="
      cat ~/.kube/config | grep "server:" || true
      echo "== Checking contexts =="
      cat ~/.kube/config | grep -E "current-context|name:" || true
      echo "== First 10 lines of kubeconfig =="
      head -n 10 ~/.kube/config || true

    # 4) Check cluster health
    - |
      echo "== Cluster info =="
      kubectl cluster-info
      kubectl get nodes

  script:
    # 5) Input the location of the generated image
    - |
      set -euo pipefail
      
      echo "== Resolve IMAGE =="
      IMAGE="$CI_REGISTRY_IMAGE:$CI_COMMIT_SHA"
      echo "IMAGE=$IMAGE"
      export IMAGE

    # 6) prepare k8s manifest
    - |
      mkdir -p /tmp/k8s

      cp Kubernetes/configmap.yaml        /tmp/k8s/configmap.yaml
      cp Kubernetes/Freelancer-mysql.yaml /tmp/k8s/mysql.yaml
      cp Kubernetes/Freelancer-mongo.yaml /tmp/k8s/mongo.yaml
      cp Kubernetes/mongo-init.yaml       /tmp/k8s/mongo-init.yaml
      cp Kubernetes/ingress.yaml          /tmp/k8s/ingress.yaml
      cp Kubernetes/flyway.yaml           /tmp/k8s/flyway.yaml
      cp Kubernetes/flyway-sql.yaml       /tmp/k8s/flyway-sql.yaml
      
      envsubst < Kubernetes/Freelancer-app.yaml > /tmp/k8s/app.yaml
      echo "=== Rendered app.yaml (image lines) ==="
      grep -n 'image:' /tmp/k8s/app.yaml || true

    # 7) Print Namespace
    - |
      echo "Namespace value is: '$NS'"

    # 8) Set up secrets
    - |
      kubectl get ns "$NS" >/dev/null 2>&1 || kubectl create ns "$NS"

      kubectl -n "$NS" create secret generic freelancer-secret \
        --from-literal=MYSQL_DATABASE="$MYSQL_DATABASE" \
        --from-literal=MYSQL_USER="$MYSQL_USER" \
        --from-literal=MYSQL_PASSWORD="$MYSQL_PASSWORD" \
        --from-literal=MYSQL_ROOT_PASSWORD="$MYSQL_ROOT_PASSWORD" \
        --from-literal=MONGO_INITDB_ROOT_USERNAME="$MONGO_INITDB_ROOT_USERNAME" \
        --from-literal=MONGO_INITDB_ROOT_PASSWORD="$MONGO_INITDB_ROOT_PASSWORD" \
        --from-literal=SPRING_DATA_MONGODB_URI="$SPRING_DATA_MONGODB_URI" \
        --from-literal=JWT_PRIVATE_KEY="$JWT_PRIVATE_KEY" \
        --from-literal=MAIL_USERNAME="$MAIL_USERNAME" \
        --from-literal=MAIL_PASSWORD="$MAIL_PASSWORD" \
        --from-literal=TEST_MAIL_FROM="$TEST_MAIL_FROM" \
        --from-literal=TEST_MAIL_TO="$TEST_MAIL_TO" \
        --dry-run=client -o yaml | kubectl -n "$NS" apply -f -

    # 10) Apply manifest
    - |
      set -euo pipefail
      kubectl -n "$NS" apply -f /tmp/k8s/mongo-init.yaml
      kubectl -n "$NS" apply -f /tmp/k8s/mongo.yaml
      kubectl -n "$NS" apply -f /tmp/k8s/ingress.yaml
      kubectl -n "$NS" apply -f /tmp/k8s/configmap.yaml
      kubectl -n "$NS" apply -f /tmp/k8s/mysql.yaml


      echo "== Apply Flyway SQL ConfigMap & Job =="

      kubectl -n "$NS" apply -f /tmp/k8s/flyway-sql.yaml

      kubectl -n "$NS" delete job flyway-migrate --ignore-not-found=true

      kubectl -n "$NS" apply -f /tmp/k8s/flyway.yaml

      echo "== Wait Flyway migration done =="

      if ! kubectl -n "$NS" wait --for=condition=complete job/flyway-migrate --timeout=300s; then
        echo "❌ Flyway migration failed or timed out"

        echo "---- job ----"
        kubectl -n "$NS" get job flyway-migrate -o wide || true
        kubectl -n "$NS" describe job flyway-migrate || true

        echo "---- pods ----"
        kubectl -n "$NS" get pods -l job-name=flyway-migrate -o wide || true

        echo "---- logs ----"
        kubectl -n "$NS" logs job/flyway-migrate || true

        exit 1
      fi

      echo "✅ Flyway migration finished. Logs:"
      kubectl -n "$NS" logs job/flyway-migrate || true

      echo "== Apply application deployment (spring-freelancer) =="
      kubectl -n "$NS" apply -f /tmp/k8s/app.yaml

    # 10) Wait for rollout
    - |
      set -e

      kubectl -n "$NS" rollout status statefulset/mysql --timeout=180s || true
      kubectl -n "$NS" rollout status deployment/spring-freelancer --timeout=180s || true

      echo "---- pods ----"
      kubectl -n "$NS" get pods -o wide

      echo "---- pvc ----"
      kubectl -n "$NS" get pvc

  environment:
    name: production

