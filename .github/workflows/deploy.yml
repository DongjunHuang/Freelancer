name: Deploy

on:
  workflow_dispatch:
    inputs:
      image:
        description: "Full image ref (e.g. ghcr.io/<owner>/<repo>:<tag>), or just a tag like <sha> or run-12345"
        required: true

jobs:
  deploy:
    runs-on: ubuntu-latest
    env:
      NS: default
      KUBECONFIG_INLINE: ${{ secrets.KUBECONFIG_INLINE }} 
      
    steps:
      # 1. Prepare K8S
      - name: Setup kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: 'v1.30.2'
      
      # 2. Check if secrets available 
      - name: Assert kubeconfig secret exists
        run: |
          test -n "${{ secrets.KUBECONFIG_INLINE }}" || { echo "KUBECONFIG_B64 not set"; exit 1; }

      # 3. Verify the private key of the VPS
      - name: Debug kubeconfig (safe)
        run: |
          echo "== Checking server address =="
          echo "${KUBECONFIG_INLINE}" | base64 -d | grep "server:"
          echo "== Checking contexts =="
          echo "${KUBECONFIG_INLINE}" | base64 -d | grep -E "current-context|name:"
          echo "== Showing first 10 lines =="
          echo "${KUBECONFIG_INLINE}" | base64 -d | head -n 10

      # 4. Prepare kube config 
      - name: Write kubeconfig
        run: |
          set -euo pipefail
          mkdir -p ~/.kube
          printf '%s' "${KUBECONFIG_INLINE}" | base64 -d > ~/.kube/config
          
          if [ ! -s ~/.kube/config ]; then
            echo "❌ ~/.kube/config not created"; exit 1
          fi
          
          chmod 600 ~/.kube/config
          echo "== server =="
          kubectl config view --raw --minify | sed -n 's/^[[:space:]]*server:[[:space:]]*//p'
      
      # 5. Check the cluster information    
      - name: Check cluster
        run: |
          kubectl cluster-info
          kubectl get nodes    
          
      # 6. Find image from build workflow
      - name: Resolve IMAGE
        run: |
          REPO_LC="${GITHUB_REPOSITORY,,}"
          if echo "${{ inputs.image }}" | grep -q '/'; then
            echo "IMAGE=${{ inputs.image }}" >> $GITHUB_ENV
          else
            echo "IMAGE=ghcr.io/${REPO_LC}:${{ inputs.image }}" >> $GITHUB_ENV
          fi
          echo "Will deploy IMAGE=$IMAGE"
  
      # 7. Checkout source code ready to deploy
      - name: Checkout
        uses: actions/checkout@v4

      # 8. Install envsubst
      - name: Install envsubst
        run: sudo apt-get update && sudo apt-get install -y gettext-base
      
      # 9. Copy yaml files to deploy online temporary repo
      - name: Render manifests
        run: |
          mkdir -p /tmp/k8s

          cp Kubernetes/configmap.yaml /tmp/k8s/configmap.yaml
          cp Kubernetes/Freelancer-mysql.yaml /tmp/k8s/mysql.yaml
          cp Kubernetes/Freelancer-mongo.yaml /tmp/k8s/mongo.yaml
          cp Kubernetes/mongo-init.yaml /tmp/k8s/mongo-init.yaml
          cp Kubernetes/ingress.yaml /tmp/k8s/ingress.yaml
          
          export IMAGE="$IMAGE"
          envsubst < Kubernetes/Freelancer-app.yaml > /tmp/k8s/app.yaml
          echo "=== Rendered app.yaml ==="
          grep -n 'image:' /tmp/k8s/app.yaml || true

      # 10. Print namespace
      - name: Debug NS
        run: |
          echo "Namespace value is: '$NS'"
    
      # 11. Apply secrets directly to the VPS without hardcode
      - name: Upsert Secret (freelancer-secret)
        run: |
          kubectl get ns "$NS" >/dev/null 2>&1 || kubectl create ns "$NS"
          kubectl -n "$NS" create secret generic freelancer-secret \
            --from-literal=MYSQL_DATABASE="${{ secrets.MYSQL_DATABASE }}" \
            --from-literal=MYSQL_USER="${{ secrets.MYSQL_USER }}" \
            --from-literal=MYSQL_PASSWORD="${{ secrets.MYSQL_PASSWORD }}" \
            --from-literal=MYSQL_ROOT_PASSWORD="${{ secrets.MYSQL_ROOT_PASSWORD }}" \
            --from-literal=MONGO_INITDB_ROOT_USERNAME="${{ secrets.MONGO_INITDB_ROOT_USERNAME }}" \
            --from-literal=MONGO_INITDB_ROOT_PASSWORD="${{ secrets.MONGO_INITDB_ROOT_PASSWORD }}" \
            --from-literal=SPRING_DATA_MONGODB_URI="${{ secrets.SPRING_DATA_MONGODB_URI }}" \
            --dry-run=client -o yaml | kubectl -n "$NS" apply -f -
      
      # 12. Start deployment
      - name: Apply manifests
        run: |
          set -euo pipefail
          kubectl -n "$NS" apply -f /tmp/k8s/mongo-init.yaml
          kubectl -n "$NS" apply -f /tmp/k8s/mongo.yaml
          kubectl -n "$NS" apply -f /tmp/k8s/ingress.yaml
          kubectl -n "$NS" apply -f /tmp/k8s/configmap.yaml
          kubectl -n "$NS" apply -f /tmp/k8s/mysql.yaml
          kubectl -n "$NS" apply -f /tmp/k8s/app.yaml
          
      # 13. post deployment
      - name: Wait for rollout
        run: |
          set -e
          
          kubectl -n "$NS" rollout status statefulset/mysql --timeout=180s || true
          kubectl -n "$NS" rollout status deployment/spring-freelancer --timeout=180s || true
          echo "---- pods ----"
          kubectl -n "$NS" get pods -o wide
          echo "---- pvc ----"
          kubectl -n "$NS" get pvc
